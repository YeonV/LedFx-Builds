name: Build Song Detector

on:
  workflow_dispatch:
    inputs:
      fversion:
        description: 'Frontend Version'
        required: true
      release:
        description: 'Is Release? (Yes/No)'
        required: true
        default: 'No'
      upload_url:
        description: 'Release upload URL'
        required: false

jobs:
  build:
    name: Build Song Detector (${{ matrix.variant }}) - ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            variant: standard
            spec_file: song-detector.spec
            artifact_name: song-detector.exe
            output_name: song-detector.exe
          - os: windows-latest
            variant: plus
            spec_file: song-detector-plus.spec
            artifact_name: song-detector-plus.exe
            output_name: song-detector-plus.exe
          - os: ubuntu-latest
            variant: standard
            spec_file: song-detector.spec
            artifact_name: song-detector-linux
            output_name: song-detector
          - os: ubuntu-latest
            variant: plus
            spec_file: song-detector-plus.spec
            artifact_name: song-detector-plus-linux
            output_name: song-detector-plus
          - os: macos-latest
            variant: standard
            spec_file: song-detector.spec
            artifact_name: song-detector-macos
            output_name: song-detector
          - os: macos-latest
            variant: plus
            spec_file: song-detector-plus.spec
            artifact_name: song-detector-plus-macos
            output_name: song-detector-plus

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Poetry
        run: |
          pip install poetry

      - name: Install dependencies (Windows)
        if: matrix.os == 'windows-latest'
        working-directory: ./tools/song-detector
        run: |
          poetry install --no-interaction

      - name: Install dependencies (Linux)
        if: matrix.os == 'ubuntu-latest'
        working-directory: ./tools/song-detector
        run: |
          sudo apt-get update
          sudo apt-get install -y libdbus-1-dev libdbus-glib-1-dev
          poetry install --no-interaction

      - name: Install dependencies (macOS)
        if: matrix.os == 'macos-latest'
        working-directory: ./tools/song-detector
        run: |
          poetry install --no-interaction

      # Code Signing Setup for macOS
      - name: Import macOS Code Signing Certificate
        if: matrix.os == 'macos-latest'
        env:
          MACOS_CERTIFICATE_BASE64: ${{ secrets.MACOS_CERTIFICATE_BASE64 }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          
          # Import certificate from secrets
          echo -n "$MACOS_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
          
          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$MACOS_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH
          
          # Allow codesign to access the keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

      - name: Set up Apple API Key for Notarization
        if: matrix.os == 'macos-latest'
        env:
          APP_STORE_CONNECT_API_PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_API_PRIVATE_KEY }}
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          # Create the private key file
          mkdir -p ~/private_keys
          echo "$APP_STORE_CONNECT_API_PRIVATE_KEY" > ~/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}.p8
          
          # Export environment variables for notarization
          echo "APPLE_API_KEY_PATH=$HOME/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}.p8" >> $GITHUB_ENV
          echo "APPLE_API_KEY_ID=${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}" >> $GITHUB_ENV
          echo "APPLE_API_ISSUER=${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}" >> $GITHUB_ENV

      - name: Detect Code Signing Identity
        if: matrix.os == 'macos-latest'
        run: |
          # Find the Developer ID Application certificate
          IDENTITY=$(security find-identity -v -p codesigning | grep "Developer ID Application" | head -1 | grep -o '[A-F0-9]\{40\}')
          echo "Found signing identity: $IDENTITY"
          echo "CODESIGN_IDENTITY=$IDENTITY" >> $GITHUB_ENV

      - name: Build with PyInstaller
        working-directory: ./tools/song-detector
        env:
          CODESIGN_IDENTITY: ${{ env.CODESIGN_IDENTITY }}
        run: |
          poetry run pyinstaller ${{ matrix.spec_file }}

      - name: Rename output
        working-directory: ./tools/song-detector/dist
        run: |
          mv ${{ matrix.output_name }} ${{ matrix.artifact_name }}

      - name: Sign, Notarize and Staple Binary (macOS)
        if: matrix.os == 'macos-latest'
        working-directory: ./tools/song-detector/dist
        run: |
          echo "üîê Verifying PyInstaller signing of ${{ matrix.artifact_name }}..."
          
          # Verify signature (should already be signed by PyInstaller)
          codesign --verify --deep --strict --verbose=2 ${{ matrix.artifact_name }}
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Binary signed successfully by PyInstaller"
          else
            echo "‚ùå ERROR: Binary signature verification failed"
            exit 1
          fi
          
          # Display signature details
          codesign -dvvv ${{ matrix.artifact_name }}
          
          # Create zip for notarization (notarytool requires zip/dmg/pkg)
          echo "üì¶ Creating zip for notarization..."
          ditto -c -k --keepParent ${{ matrix.artifact_name }} ${{ matrix.artifact_name }}.zip
          
          # Submit for notarization
          echo "üîê Submitting for notarization..."
          xcrun notarytool submit ${{ matrix.artifact_name }}.zip \
            --key "$APPLE_API_KEY_PATH" \
            --key-id "$APPLE_API_KEY_ID" \
            --issuer "$APPLE_API_ISSUER" \
            --wait
          
          if [ $? -ne 0 ]; then
            echo "‚ùå ERROR: Binary notarization failed"
            echo "üìã Getting notarization log..."
            xcrun notarytool log \
              --key "$APPLE_API_KEY_PATH" \
              --key-id "$APPLE_API_KEY_ID" \
              --issuer "$APPLE_API_ISSUER" \
              $(xcrun notarytool history --key "$APPLE_API_KEY_PATH" --key-id "$APPLE_API_KEY_ID" --issuer "$APPLE_API_ISSUER" | head -n 2 | tail -n 1 | awk '{print $2}')
            exit 1
          fi
          
          # Staple the notarization ticket (note: stapling to bare executables doesn't persist, but we try anyway)
          echo "üìé Attempting to staple notarization ticket..."
          xcrun stapler staple ${{ matrix.artifact_name }} || echo "‚ö†Ô∏è  Stapling not supported for bare executables (expected)"
          
          # Verify notarization
          echo "‚úÖ Verifying notarization..."
          spctl -a -vvv -t install ${{ matrix.artifact_name }} || echo "‚úÖ Binary is notarized (spctl check may fail for non-bundled executables)"
          
          # Remove the temporary zip file
          rm ${{ matrix.artifact_name }}.zip
          
          echo "‚úÖ ${{ matrix.artifact_name }} signing and notarization complete"
          
      # Cleanup: Remove certificate and API key for security
      - name: Cleanup macOS Code Signing
        if: always() && matrix.os == 'macos-latest'
        run: |
          # Remove the keychain
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
          
          # Remove the API key file
          rm -f ~/private_keys/AuthKey_*.p8 || true
          
          # Remove the certificate file
          rm -f $RUNNER_TEMP/certificate.p12 || true

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: ./tools/song-detector/dist/${{ matrix.artifact_name }}

      - name: Upload to Release
        if: ${{ github.event.inputs.release == 'Yes' }}
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.inputs.upload_url }}
          asset_path: ./tools/song-detector/dist/${{ matrix.artifact_name }}
          asset_name: ${{ matrix.artifact_name }}
          asset_content_type: application/octet-stream
